/*
transmit.c - Transmit module for stalk
Author - Matt Whitehead mbwhiteh@sfu.ca
*/
#include "transmit.h"

//LOCAL SCOPED VARIABLES
pthread_t threadId = 0;
int threadRt = 0;
static struct tx_arguements_s txArgs = {0,NULL,NULL,NULL,NULL,NULL};
static struct sockaddr_in peerComm_s;

//Transmission thread to do work
void * tx_thread(void * argsIn)
{
    struct tx_arguements_s * txData = (struct tx_arguements_s *) argsIn;
    char * msgTx = NULL;
    int mutexErr = 0;

    //Init the cleanup handler and args
    cleanup_args cleanItems = {txData->mutex,msgTx};
    
    while(mutexErr == 0)
    {
        mutexErr = pthread_mutex_lock(txData->mutex);
        {
            //Deqeue the buffer once a singal has been received to wake up from the user_input thread
            mutexErr = pthread_cond_wait(txData->mutexCond,txData->mutex);
            msgTx = List_trim(txData->dataTx);
        }
        mutexErr = pthread_mutex_unlock(txData->mutex);
        
        //Messages are in the buffer list deqeue them
        while(msgTx != NULL)
        {
            //Update clean up handlers before cancelation point
            cleanItems.dataToFree = msgTx;
            pthread_cleanup_push(cleanup_handler,&cleanItems)
            //Sendto is a cancelation point, no need to test for cancellation
            if(sendto(txData->socketId,msgTx,MSG_TX_LEN,0,(struct sockaddr*) txData->peerCnx,sizeof(struct sockaddr_in)) == -1)
            {
                printf("ERROR: sendto in %s\n",__FILE__);
                mutexErr = pthread_cond_signal(txData->sysFlag);
            }
            
            //Remove dynamic memory associated with the received messsage !Generated by User_Init()!
            free(msgTx);

            msgTx = NULL;
                        
            //If work is still being done, dequing more messages
            mutexErr = pthread_mutex_lock(txData->mutex);
            msgTx = List_trim(txData->dataTx);
            mutexErr = pthread_mutex_unlock(txData->mutex);

            //If not canceled remove current loop addresses from clean up handler's stack
            pthread_cleanup_pop(0);
        }
    }
    if(mutexErr != 0)
    {
        printf("ERROR: pthread_mutex in %s\n",__FILE__);
        mutexErr = pthread_cond_signal(txData->sysFlag);
    }
    pthread_exit(NULL);
}

//Init the transmission thread
pthread_t Transmit_Init(int socketIdIn,List * dataIn, pthread_mutex_t * mutexIn, pthread_cond_t * mutexCondIn,\
    char * txPortIn,char * txAddrIn,pthread_cond_t * sysFlagIn)
{

    struct addrinfo addrHints; 
    struct addrinfo * addList;
    struct addrinfo * itr;
    memset(&addrHints,0,sizeof(struct addrinfo));
    addrHints.ai_flags = 0;
    addrHints.ai_family = AF_INET;
    addrHints.ai_socktype = SOCK_DGRAM;
    addrHints.ai_protocol = IPPROTO_UDP;

    //Loop through any addresses
    if(getaddrinfo(txAddrIn,txPortIn,&addrHints,&addList) != 0)
    {
        printf("ERROR: Generating Remote Address \n");
        exit(-1);
    }

    for(itr = addList; itr != NULL; itr = itr->ai_next)
    {
        peerComm_s  = *((struct sockaddr_in *) itr->ai_addr);
    }

    //Freeing the addr list
    freeaddrinfo(addList);

    //Initiate transmit thread argumenets
    txArgs.socketId = socketIdIn;
    txArgs.dataTx = dataIn;
    txArgs.mutex = mutexIn;
    txArgs.mutexCond = mutexCondIn;
    txArgs.sysFlag = sysFlagIn;
    txArgs.peerCnx = &peerComm_s;

    char pForm[INET_ADDRSTRLEN];
    inet_ntop(AF_INET,&(peerComm_s.sin_addr),pForm,INET_ADDRSTRLEN);
    printf("Connected to %s\n",pForm);
    
    
    //Create transmission thread
    threadRt = pthread_create(&threadId,NULL,tx_thread,&txArgs);

    return threadId;

}

//Join the transmit thread if it has been cancelled
void Transmit_Shutdown(void)
{
    if(pthread_join(threadId,NULL) != 0)
        printf("ERROR: pthread_join(threadId) \n");
}